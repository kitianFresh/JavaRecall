# JavaRecall
pick up my java

## Basics
  1. 向函数传递可变参数,不管arguments是多个参数还是数组都行，因为实际上compiler会把varargs转换为数组

  2. 使用三目运算符或者!可以反转一个boolean,！无法用在integer和real以及object reference上，只能用在boolean上

  3. only integers(byte,char,short,int,long) can use bitwise operator

### static blocks && class initialize && instance initialize

#### example BBOperator.java
  1. 理清头绪后可以看出，Java虚拟机在看到左边的类出现的时候，就会去寻找该类的代码，首先初始化该类的类属性，也就是static属性(包括static variable，static blocks)，按照在代码中出现的先后顺序，依次执行可以执行的初始化语句或者代码块。这也是为啥static里面无法访问在后面顺序申明的静态成员变量，并且更加不能访问非静态变量即实例变量的原因，因为这不符合先有类后有类实例的原则；并且类在jvm加载一次初始化完成之后就不会再执行初始化了，也就是所有的static在类被首次load到jvm时仅仅执行一次;
  2. 对于类的实例，则是当java虚拟机扫描到new关键字的时候，就会执行构造函数创建类的实例,此时非static{}代码块会被插入到类的构造函数最前面(其实就等价于在{}里面的代码写到构造函数最前面一样),这也是为啥jvm在扫描类的时候不管{}代码块的原因，因为他是属于类实例的，和类无关,并且此时的实例变量都是默认值，因为这个实例还没有完全构造出来，{}只是插在构造函数前面的一段代码,所以t7的初始化要看他插在{}代码块儿之前还是之后，结果是不一样的，也有先后次序之分;
  
#### summary
  1. jvm解释执行代码时，遇到新的类时，首先加载这个类；
  2. 类初始化过程中，按static顺序执行静态成员初始化语句或static blocks；且只执行一次；
  3. 先有类，后才有类实例原则，静态成员属于类，实例成员属于实例-->一系列规则;
    - 静态方法中可以存取静态变量和其他静态方法，不可以存取实例变量和方法
    - 非静态方法可以存取一切静态方法和静态成员变量
    - 类实例可以调用一切静态方法
  4. 实例从new中产生，必定由构造函数构造出;
  5. 类实例的初始化不管时成员初始化private a = 3;还是{}代码块初始化，实际上都是按照在代码中出现的先后顺序被插入到构造函数最前面；